---
title: 面经总结
tags: 面经
---

下面是对面试的一些记录，总结，因为是面试结束之后进行回忆的，可能会漏掉些许问题，提问顺序也不太对。

## 2022-4-11 字节 一面

1. 自我介绍
2. 快排原理
3. 堆和栈的区别
   - 数据结构中的区别
   - 操作系统中的区别
4. 了解哈希表吗？哈希表的原理，冲突，时间复杂度
5. 了解计算机网络吗
   - 简单介绍了一下网络模型
   - 简单说了一下 TCP, UDP
6. 了解 http 吗？get, post 的区别？（不会）
7. TCP 与 UDP 的区别
8. 三次握手四次挥手
   - 服务器向客户端发 SYN/ACK 之后，TCP 处于什么状态（半连接）
9. `TCP` 的重传，发送方送出 [1,2,3,4]，接收方收到 [1,2,4]，之后发送方该怎么办
10. 串行和并行，同步与异步了解吗，区别
11. 了解事务吗，事务是什么？（不会）
12. 死锁是什么
13. 算法题
    - 二叉搜索树的镜像（二叉树变成左节点大于当前节点，右孩子小于当前节点）
        > 问：递归写法，直接交换左右孩子没问题吗，不需要中间变量吗？
        > 只写出了递归的写法，迭代的没写出来，迭代应该类似于后序遍历
    - 一个数组，把数组中的 0 放到数组后端，不能调换非零元素的相对次序，不能用额外空间
        > 最优解应该是快慢指针，但没写出来

## 2022-9-13 4399 一面

1. 自我介绍，问了简历，做了什么项目，在学校做什么项目，玩的游戏，为什么选游戏岗，平时时间分配
2. c++ 方面
3. `struct {int, char, double}` 结构体多大（内存对齐）
4. new malloc 的区别，对构造函数的影响，如果在内存不足的情况下，malloc 和 new 的应对措施
5. 重载和重写的区别
6. 空类的大小？类里只有一个函数，大小？
    - 1, 1
7. 进程与线程的区别
8. 资源调度的最小单位，cpu调度的最小单位
9. 同一个进程里不同的线程之间的区别
10. 50!（50 的阶乘） 多少个 0（12 个，25、50 特殊点）
11. 指针和引用的区别
12. 你常用的数据结构有哪些，栈和队列是什么，二叉树的遍历方式
13. 面向对象的特性
14. 哈希表，冲突的解决方式

## 2022-9-21 润科通用 一面

还是紧张了，有点小尴尬。

1. 自我介绍，做了什么项目？
2. 项目是做什么的，是跟着视频去做的吗
3. linux 下的调试方式了解吗（我说 gdb），gdb 下如何打断点，查看堆栈，查看变量
4. stl 的容器，map 是做什么的，红黑树的查找时间复杂度
5. vector 和 list 的区别，以及 vector 在空间不足的情况下扩容的情况，扩容之后的大小？
6. 多线程，在 linux 创建线程的函数是什么
7. 多线程的同步方式
8. 多进程
9. 多进程的同步方式
10. 什么情况下用锁（互斥锁？具体记不清了），什么情况下用信号量
11. 共享内存了解吗
12. 结构体与联合体的区别
13. 多态是什么（只解释了多态的用法，还是没到点上）
14. 构造函数可以是虚函数吗，析构函数呢
15. tcp/ip 方面， tcp/udp 了解吗，拿来做过什么项目吗（我说没有做过相关的项目，但是了解基本原理，之后就问其他的了）
16. linux shell 方面，top 命令干嘛的，如何查找特定的文件，如何查找特定进程的 pid
17. 成绩，四六级相关情况
18. 期望城市，薪资
19. 反问，问了工作时间，早九晚八，然后脑抽没问了

## 2022-9-26 荣耀 一面 30min

1. 自我介绍，介绍一下项目（红黑树跟 xv6）
2. 项目做了红黑树了，介绍一下（插入，查找，删除等），时间复杂度
3. 那 stl 里边哪些用到了红黑树，介绍一下（set，map）
4. set 与 map 的区别
5. set 与 unordered_map 的区别，相应操作的时间复杂度
6. vector 与 deque 的底层实现
7. vector 的扩容问题
8. vector 中 reserve 与 resize 的区别
9. 项目里有没有用到 c++ 的特性之类的
10. new/delete 与 malloc/free 的区别
11. 指针与引用的区别，如何使指针指向的地址不变
12. 多态，多态的使用场景
13. sizeof(指针)，sizeof(引用),sizeof(shared_ptr) 的区别
14. shared_ptr 与 union_ptr 的区别，使用场景，shared_ptr 存在的问题，以及如何解决相应问题
15. 多态相关的问题，存在五个类 A,B,C,D,E，C 继承 A，D 继承 B，E 继承 C 和 D，其中 A,D,E 存在同名函数 m，
    在 E 的对象调用 m 时，存在虚函数与没有虚函数的区别，以及 E 如何调用 A.m 与 D.m
16. 多线程中锁的问题，A 持有锁 lock，B 持有锁 lock，A 中可能会需要调用 B，会发生什么问题，解决办法
17. 重载与重写的区别，使用场景等
18. 多态中，父类的指针转换为子类的指针，安全吗？需要用到什么类型转换

## 问题的解答

### 结构体 struct 与联合 union 的区别

struct: 用户自定义的数据类型，可以存储不同类型的数据，数据成员按定义顺序存放，结构体大小为所有成员的长度之和，同时遵循内存对齐原则。

union: 特殊的数据类型，各成员共用同一块内存空间，各成员共用同一个内存首地址，大小为最大成员的大小。

### new 与 malloc 的区别，对构造函数的影响，内存不足的情况下他们的应对措施

看我另外一篇 `new vs malloc`。

### 哈希表，冲突，相应的解决方法，时间复杂度等

哈希表：将 key 通过散列函数（哈希函数）某一个位置，之后通过 key 值来直接访问的数据结构。
通常情况下哈希表的查询，插入，删除的时间为 $O(1)$；最坏的情况下，时间复杂度可能为 $O(n)$。

冲突：现在有两个 key 值，(k1, k2)，哈希函数为 f(k)，存在 f(k1) == f(k2)，即出现冲突了。

处理冲突的方法：

1. 开放寻址法（Hi=(H(key) + di) mod m，H(key) 为哈希函数，m 为哈希表长，di 为增量序列）
    - di: 1,2,3,4,...,m-1，线性探测再散列
    - di: 1^2,-1^2,2^2,-2^2,...,(km/2)，二次探测再散列
    - di: 伪随机数序列，称伪随机探测再散列
2. 再散列法（在出现冲突时，计算另一个哈希函数得到地址，直到冲突不在出现，增加了计算时间）
3. 链地址法（数组与链表的结合，将相同的 hash 地址记录在链表上，链表的表头为计算得到的 hash 地址）
4. 公共溢出区

参考：

- <https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/5981869?fr=aladdin>

### 空类

空类指的是：不包含任何成员变量的类，空类可能存在成员函数。

空类的大小为 1？类只有在进行实例化的时候才会分配空间，没有对象的类不需要分配空间。
在类进行初始化时，编译器分配 1 字节的空间给空类的对象，用于对地址的唯一标识。

如下面代码所示，在栈上存在两个空类对象 a 和 b，如果说空类对象的空间为 0，这就导致 a 和 b 在栈上的地址相同，无法有效的区分开 a 与 b，
所以为空类分配一个字节，就能够将 a b 在栈上的地址区分开。

```cpp
#include <iostream>

using namespace std;

class Empty {

};

int main() {
    // 检查空类的大小
    cout << "空类的大小：" << sizeof(Empty) << endl;
    Empty a, b;
    cout << "两个相同类型的空类对象的地址相同？" << (&a == &b) << endl;
    cout << "空类 a 的地址：" << &a << endl;
    cout << "空类 b 的地址：" << &b << endl;
}
```

output

```sh
空类的大小：1
两个相同类型的空类对象的地址相同？0
空类 a 的地址：0x7ffc534900e6
空类 b 的地址：0x7ffc534900e7
```

```cpp
#include <iostream>

using namespace std;

class Empty {

};

class Derived: public Empty {
    int a;
};

int main() {
    // 检查空类的大小
    cout << "空类的大小：" << sizeof(Empty) << endl;
    Empty a, b;
    cout << "两个相同类型的空类对象的地址相同？" << (&a == &b) << endl;
    cout << "空类 a 的地址：" << &a << endl;
    cout << "空类 b 的地址：" << &b << endl;
    cout << "空类的大小：" << sizeof(Empty) << endl;
    cout << "空类子类的大小： " << sizeof(Derived) << endl;
}
```

output

```sh
空类的大小：1
两个相同类型的空类对象的地址相同？0
空类 a 的地址：0x7ffc49337306
空类 b 的地址：0x7ffc49337307
空类的大小：1
空类子类的大小： 4
```

此时，空类的子类有成员变量了，不需要在多分配 1 字节用于区分地址了。

另外，空类在定义时会生成 6 个成员函数

```cpp
class Empty {

};

// 等价于
class Empty {
public:
    // 默认的构造函数
    Empty() {}
    // 拷贝构造函数
    Empty(const Empty &rhs) {}
    // 析构函数
    ~Empty() {}
    // 赋值运算符
    Empty& operator=(const Empty &rhs);
    // 取址运算符
    Empty* operator&();
    // 取址运算符 const
    const Empty* operator&() const;
};
```

参考:

- <https://www.geeksforgeeks.org/why-is-the-size-of-an-empty-class-not-zero-in-c/>
- <https://blog.csdn.net/ox0080/article/details/84162776>
